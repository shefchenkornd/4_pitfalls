package main

type X struct{}

func (*X) GetValue() {}

type Y struct {
	X
}

type Z struct {
	X X
}

// В языке Go нет наследования — есть только композиция (встраивание):
// При этом обратите внимание, что встраивание в структурах Y и Z разное — в первом случае оно "безымянное",
// благодаря чему можно вызывать методы X прямо из структуры Y (пример: Y{}.GetValue() вернёт 0 как значение int по умолчанию),
// а во втором случае создаётся поле X типа X, из-за чего вызывать методы нельзя (пример: Z{}.GetValue() вызовет ошибку при компиляции).
//
// Сделать, чтобы к полю Value из структуры X можно было обратиться из структуры Y или Z нельзя (в вашем случае обратиться к полю field1 из child)
func main() {
	y := Y{}
	y.GetValue()   // напрямую вызвать метод GetValue() МОЖНО, потому что в структуре Z{} есть "безымянное" поле
	y.X.GetValue() // можно

	z := Z{}
	z.X.GetValue()
	// z.GetValue() // напрямую вызвать метод GetValue() НЕЛЬЗЯ, потому что в структуре Z{} у поля есть имя 'X'.
}
