# Оглавление
1. 4 подводных камня на Go, на которые часто натыкаются
2. Вопрос по Golang на миллион долларов
3. Буферизированный ввод-вывод
4. Приведение типов
5. Каналы
6. Проверка на имплементацию структуры repo интерфейса Repo
7. Конкатенация строк 4 способа
8. defer и его принцип работы LIFO (англ. Last In, First Out – «последним пришёл — первым ушёл»)
9. Неопределенное количество параметров в функции [ставится многоточие: numbers ...int]
10. Goroutine: чтение из канала
11. Goroutine select
12. Полиморфизм на примере имплементации метода интерфейса и структур
13. Интерфейс io.Reader & io.Writer
14. sync.Mutex
15. net/http packages
16. Организация кода в Go
17. os package
18. Стандартные потоки вывода в Go
19. panic()
20. Указатели как параметры функции
21. Struct and nested structs
22. Именованные типы. Именованный тип основывается на уже существующем типе.
23. unit-tests
24. sync.WaitGroup
25. backend tests
26. переключатель типов (type switch)
27. Многомерные слайсы и массивы
28. Неизменяемость строк
29. Десериализация (unmarshalling) JSON-чисел в интерфейсные значения. По умолчанию Golang обращается с числовыми значениями в JSON как с числами float64
30. Сравнение struct, array, slice и map. Можно использовать оператор эквивалентности == для сравнения переменных структур, если каждое поле структуры можно сравнить с помощью этого оператора.
31. Перехват panic
32. Обновление и привязка значений полей в slice, array и map в выражениях for range
33. «Скрытые данные» в слайсах
34. Patterns: «Цепочка обязанностей» - это поведенческий паттерн проектирования, который позволяет передавать задачи на обработку последовательно по цепочке
35. «Повреждение» данных в слайсах или Three-index slices sl[:i:j], где j - это ёмкость исходного массива
36. «Устаревшие» слайсы
37. Методы и объявления типов. Если вам нужны методы из исходного типа, вы можете задать новый тип структуры, встроив исходный в качестве анонимного поля.
38. Как выбраться из кодовых блоков for switch и for select с помощью метки
39. Итерационные переменные и замыкания в выражениях for
40. Вычисление аргумента блока defer (Deferred Function Call Argument Evaluation)
41. Вызов блока defer в цикле FOR{}