package main

import (
	"fmt"
	"sync"
	"time"
)

/*
Deadlock — это ошибка, которая происходит когда процессы имеют циклическую зависимость от пары синхронизированных объектов

Существуют условия Кофмана, которые помогают обнаруживать, предотвращать и исправлять взаимные блокировки:
  1. условия взаимного исключения. Каждый ресурс в данный момент или отдан ровно одному процессу, или доступен.
  2. условие удержания и ожидания. Процессы, в данный момент удерживающие полученные ранее ресурсы, могут запрашивать новые ресурсы.
  3. условие отсутствия принудительной выгрузки ресурсов. У процесса нельзя принудительным образом забрать ранее полученные ресурсы. Процесс, владеющий ими, должен сам освободить ресурсы.
  4. условие циклического ожидания. Должна существовать круговая последовательность из двух и более процессов, каждый из которых ждет доступа к ресурсу, удерживаемому следующим членом последовательности.
Если хоть одно из этих условий не выполняется, то взаимных блокировок никогда не возникнет.


Диаграммы Холта (Holt) помогает отслеживать взаимные блокировки наглядно с помощью направленного графа,
где есть два типа узлов:
  * горутины в круглых скобках
  * ресурсы в квадратных скобках

Тот факт, что ресурс получен процессом и в данный момент занят этим процессом, указывается ребром (стрелкой) от ресурса к процессу.
Ребро, направленное от процесса, к ресурсу, означает, что процесс в данный момент блокирован и находится в состоянии ожидания доступа к соответствующему ресурсу.

(printSum#1) <----- [a.value]
	|					↑
	|					|
	↓					|
  [b.value] -----> (printSum#2)

Deadlock имеет место быть, тогда и только тогда, когда диаграмма Холта, отражающая состояния процессов и ресурсов, содержит цикл.
*/

type value struct {
	mu    sync.Mutex
	value int
}

func main() {
	wg := sync.WaitGroup{}

	printSum := func(v1, v2 *value) {
		defer wg.Done()

		v1.mu.Lock() // Горутина #1 блокирует А; Горутина #2 блокирует B
		defer v1.mu.Unlock()

		time.Sleep(time.Second)

		v2.mu.Lock() // Горутина #1 ожидает B; Горутина #2 ожидает А
		defer v2.mu.Unlock()

		fmt.Println(v1.value * v2.value)
	}

	a, b := value{}, value{}

	wg.Add(2)
	go printSum(&a, &b)
	go printSum(&b, &a)

	wg.Wait()
}
